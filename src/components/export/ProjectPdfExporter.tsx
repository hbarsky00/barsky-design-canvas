import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Download, FileText, Loader2 } from 'lucide-react';
import { projectsData } from '@/data/projects/projectsList';
import { projectDetails } from '@/data/project-details';
import { toast } from 'sonner';
import jsPDF from 'jspdf';

interface ProjectPdfExporterProps {
  variant?: 'button' | 'icon';
  className?: string;
}

const ProjectPdfExporter: React.FC<ProjectPdfExporterProps> = ({ 
  variant = 'button',
  className = '' 
}) => {
  const [isExporting, setIsExporting] = useState(false);

  const generateProjectPDF = async (project: typeof projectsData[0]) => {
    const details = projectDetails[project.id];
    if (!details) return null;

    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    let yPosition = margin;

    // Helper function to add text with word wrapping
    const addWrappedText = (text: string, fontSize: number = 12, isBold: boolean = false) => {
      pdf.setFontSize(fontSize);
      if (isBold) pdf.setFont(undefined, 'bold');
      else pdf.setFont(undefined, 'normal');
      
      const lines = pdf.splitTextToSize(text, contentWidth);
      lines.forEach((line: string) => {
        if (yPosition > 270) { // Check if we need a new page
          pdf.addPage();
          yPosition = margin;
        }
        pdf.text(line, margin, yPosition);
        yPosition += fontSize * 0.5;
      });
      yPosition += 5; // Add some spacing
    };

    // Add header
    pdf.setFillColor(59, 130, 246); // Blue background
    pdf.rect(0, 0, pageWidth, 40, 'F');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(24);
    pdf.setFont(undefined, 'bold');
    pdf.text(project.title, margin, 25);

    // Reset text color and position
    pdf.setTextColor(0, 0, 0);
    yPosition = 50;

    // Project overview
    addWrappedText('PROJECT OVERVIEW', 16, true);
    addWrappedText(project.description);
    
    // Project details
    addWrappedText('PROJECT DETAILS', 14, true);
    addWrappedText(`Duration: ${details.duration}`);
    addWrappedText(`Client: ${details.client}`);
    addWrappedText(`Role: ${details.role}`);
    
    if (details.projectLink) {
      addWrappedText(`Project Link: ${details.projectLink}`);
    }

    // Technologies
    addWrappedText('TECHNOLOGIES', 14, true);
    addWrappedText(details.technologies.join(', '));

    // Tags
    addWrappedText('TAGS', 14, true);
    addWrappedText(project.tags.join(', '));

    // Challenge
    addWrappedText('CHALLENGE', 14, true);
    addWrappedText(details.challenge);
    
    if (details.challengeAdditionalText) {
      addWrappedText(details.challengeAdditionalText);
    }

    // Process
    addWrappedText('PROCESS', 14, true);
    addWrappedText(details.process);

    // Result
    addWrappedText('RESULT', 14, true);
    addWrappedText(details.result);

    // Footer
    pdf.setFontSize(10);
    pdf.setTextColor(128, 128, 128);
    pdf.text('Generated by Hiram Barsky Design Portfolio', margin, 280);
    pdf.text(`Generated on: ${new Date().toLocaleDateString()}`, margin, 285);

    return pdf;
  };

  const exportAllProjectsPDF = async () => {
    setIsExporting(true);
    
    try {
      // Get all featured projects that have details
      const exportableProjects = projectsData.filter(project => 
        projectDetails[project.id] && project.featured
      );

      if (exportableProjects.length === 0) {
        toast.error('No projects available for export');
        return;
      }

      // Create a combined PDF with all projects
      const mainPDF = new jsPDF('p', 'mm', 'a4');
      let isFirstProject = true;

      for (const project of exportableProjects) {
        const projectPDF = await generateProjectPDF(project);
        if (projectPDF) {
          if (isFirstProject) {
            // Replace the first empty page
            const pages = projectPDF.internal.pages;
            mainPDF.internal.pages = pages;
            isFirstProject = false;
          } else {
            // Merge subsequent projects
            const pages = projectPDF.internal.pages.slice(1); // Skip the first empty page
            mainPDF.internal.pages.push(...pages);
          }
        }
      }

      // Save the combined PDF
      const fileName = `Hiram_Barsky_Portfolio_Projects_${new Date().toISOString().split('T')[0]}.pdf`;
      mainPDF.save(fileName);
      
      toast.success(`Successfully exported ${exportableProjects.length} projects to PDF!`);
    } catch (error) {
      console.error('Error exporting PDFs:', error);
      toast.error('Failed to export projects. Please try again.');
    } finally {
      setIsExporting(false);
    }
  };

  const exportSingleProjectPDF = async (projectId: string) => {
    setIsExporting(true);
    
    try {
      const project = projectsData.find(p => p.id === projectId);
      if (!project) {
        toast.error('Project not found');
        return;
      }

      const pdf = await generateProjectPDF(project);
      if (pdf) {
        const fileName = `${project.title.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
        pdf.save(fileName);
        toast.success(`Successfully exported ${project.title} to PDF!`);
      }
    } catch (error) {
      console.error('Error exporting PDF:', error);
      toast.error('Failed to export project. Please try again.');
    } finally {
      setIsExporting(false);
    }
  };

  if (variant === 'icon') {
    return (
      <Button
        onClick={exportAllProjectsPDF}
        disabled={isExporting}
        variant="outline"
        size="sm"
        className={className}
      >
        {isExporting ? (
          <Loader2 className="h-4 w-4 animate-spin" />
        ) : (
          <FileText className="h-4 w-4" />
        )}
      </Button>
    );
  }

  return (
    <div className={`space-y-4 ${className}`}>
      <Button
        onClick={exportAllProjectsPDF}
        disabled={isExporting}
        className="w-full sm:w-auto"
        size="lg"
      >
        {isExporting ? (
          <>
            <Loader2 className="mr-2 h-5 w-5 animate-spin" />
            Exporting...
          </>
        ) : (
          <>
            <Download className="mr-2 h-5 w-5" />
            Export All Projects to PDF
          </>
        )}
      </Button>
      
      <div className="text-sm text-muted-foreground">
        <p>This will export all {projectsData.filter(p => projectDetails[p.id] && p.featured).length} featured projects into a single PDF file.</p>
      </div>

      {/* Individual project export options */}
      <div className="space-y-2">
        <h4 className="text-sm font-medium">Export Individual Projects:</h4>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
          {projectsData
            .filter(project => projectDetails[project.id] && project.featured)
            .map(project => (
              <Button
                key={project.id}
                onClick={() => exportSingleProjectPDF(project.id)}
                disabled={isExporting}
                variant="outline"
                size="sm"
                className="justify-start text-left"
              >
                <FileText className="mr-2 h-4 w-4" />
                {project.title}
              </Button>
            ))}
        </div>
      </div>
    </div>
  );
};

export default ProjectPdfExporter;